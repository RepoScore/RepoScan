export interface Vulnerability {
  severity: 'critical' | 'high' | 'medium' | 'low';
  type: 'dependency' | 'code_pattern' | 'configuration';
  description: string;
  location: string;
  cve_id?: string;
  details?: string;
}

export interface VulnerabilitySummary {
  total_count: number;
  critical_count: number;
  high_count: number;
  medium_count: number;
  low_count: number;
  by_type: {
    dependency: number;
    code_pattern: number;
    configuration: number;
  };
}

export async function scanDependencyVulnerabilities(
  repoName: string,
  contents: any[]
): Promise<Vulnerability[]> {
  const vulnerabilities: Vulnerability[] = [];

  const packageJson = contents.find(f => f.name === 'package.json');
  if (packageJson) {
    try {
      const pkgContent = await fetchFileContent(repoName, 'package.json');
      if (pkgContent) {
        const pkg = JSON.parse(pkgContent);
        vulnerabilities.push(...analyzeNpmDependencies(pkg));
      }
    } catch (error) {
      console.error('Error analyzing package.json:', error);
    }
  }

  const requirementsTxt = contents.find(f => f.name === 'requirements.txt');
  if (requirementsTxt) {
    try {
      const reqContent = await fetchFileContent(repoName, 'requirements.txt');
      if (reqContent) {
        vulnerabilities.push(...analyzePythonDependencies(reqContent));
      }
    } catch (error) {
      console.error('Error analyzing requirements.txt:', error);
    }
  }

  const cargoToml = contents.find(f => f.name === 'Cargo.toml');
  if (cargoToml) {
    try {
      const cargoContent = await fetchFileContent(repoName, 'Cargo.toml');
      if (cargoContent) {
        vulnerabilities.push(...analyzeRustDependencies(cargoContent));
      }
    } catch (error) {
      console.error('Error analyzing Cargo.toml:', error);
    }
  }

  return vulnerabilities;
}

async function fetchFileContent(repoName: string, path: string): Promise<string | null> {
  try {
    const response = await fetch(
      `https://api.github.com/repos/${repoName}/contents/${path}`,
      {
        headers: {
          'Accept': 'application/vnd.github+json',
          'User-Agent': 'RepoScan-App'
        }
      }
    );

    if (!response.ok) return null;

    const data = await response.json();
    if (data.content) {
      return atob(data.content.replace(/\n/g, ''));
    }
    return null;
  } catch (error) {
    console.error(`Error fetching ${path}:`, error);
    return null;
  }
}

function analyzeNpmDependencies(pkg: any): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];
  const knownVulnerabilities = getKnownNpmVulnerabilities();

  const allDeps = {
    ...(pkg.dependencies || {}),
    ...(pkg.devDependencies || {}),
  };

  for (const [depName, version] of Object.entries(allDeps)) {
    const versionStr = String(version);

    if (versionStr.startsWith('file:') || versionStr.startsWith('link:')) {
      vulnerabilities.push({
        severity: 'medium',
        type: 'dependency',
        description: `Local file dependency: ${depName}`,
        location: 'package.json',
        details: 'Local dependencies can pose supply chain risks'
      });
    }

    if (versionStr === '*' || versionStr === 'latest') {
      vulnerabilities.push({
        severity: 'medium',
        type: 'dependency',
        description: `Unpinned dependency version: ${depName}@${versionStr}`,
        location: 'package.json',
        details: 'Unpinned versions can lead to unexpected breaking changes'
      });
    }

    const knownVuln = knownVulnerabilities[depName];
    if (knownVuln) {
      vulnerabilities.push({
        severity: knownVuln.severity,
        type: 'dependency',
        description: `Known vulnerability in ${depName}: ${knownVuln.description}`,
        location: 'package.json',
        cve_id: knownVuln.cve_id,
        details: knownVuln.details
      });
    }
  }

  return vulnerabilities;
}

function analyzePythonDependencies(content: string): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];
  const knownVulnerabilities = getKnownPythonVulnerabilities();

  const lines = content.split('\n');

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;

    const match = trimmed.match(/^([a-zA-Z0-9-_.]+)([>=<~!]+.*)?$/);
    if (match) {
      const packageName = match[1].toLowerCase();
      const versionSpec = match[2];

      if (!versionSpec || versionSpec.includes('>=')) {
        vulnerabilities.push({
          severity: 'low',
          type: 'dependency',
          description: `Unpinned Python dependency: ${packageName}`,
          location: 'requirements.txt',
          details: 'Consider pinning exact versions for reproducible builds'
        });
      }

      const knownVuln = knownVulnerabilities[packageName];
      if (knownVuln) {
        vulnerabilities.push({
          severity: knownVuln.severity,
          type: 'dependency',
          description: `Known vulnerability in ${packageName}: ${knownVuln.description}`,
          location: 'requirements.txt',
          cve_id: knownVuln.cve_id,
          details: knownVuln.details
        });
      }
    }
  }

  return vulnerabilities;
}

function analyzeRustDependencies(content: string): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];
  const knownVulnerabilities = getKnownRustVulnerabilities();

  const depMatches = content.matchAll(/^\s*([a-zA-Z0-9-_]+)\s*=\s*"([^"]+)"/gm);

  for (const match of depMatches) {
    const crateName = match[1];
    const version = match[2];

    if (version === '*') {
      vulnerabilities.push({
        severity: 'medium',
        type: 'dependency',
        description: `Unpinned Rust crate version: ${crateName}`,
        location: 'Cargo.toml',
        details: 'Wildcard versions can introduce unexpected changes'
      });
    }

    const knownVuln = knownVulnerabilities[crateName];
    if (knownVuln) {
      vulnerabilities.push({
        severity: knownVuln.severity,
        type: 'dependency',
        description: `Known vulnerability in ${crateName}: ${knownVuln.description}`,
        location: 'Cargo.toml',
        cve_id: knownVuln.cve_id,
        details: knownVuln.details
      });
    }
  }

  return vulnerabilities;
}

function getKnownNpmVulnerabilities(): Record<string, any> {
  return {
    'node-ipc': {
      severity: 'critical' as const,
      cve_id: 'CVE-2022-23812',
      description: 'Malicious code injection',
      details: 'Version 10.1.1+ contained malicious code targeting Russian and Belarusian users'
    },
    'event-stream': {
      severity: 'critical' as const,
      cve_id: 'CVE-2018-3721',
      description: 'Cryptocurrency wallet theft',
      details: 'Versions 3.3.6 and 4.0.1 contained malicious code stealing cryptocurrency'
    },
    'lodash': {
      severity: 'high' as const,
      cve_id: 'CVE-2021-23337',
      description: 'Prototype pollution',
      details: 'Versions before 4.17.21 vulnerable to prototype pollution'
    },
    'minimist': {
      severity: 'medium' as const,
      cve_id: 'CVE-2021-44906',
      description: 'Prototype pollution',
      details: 'Versions before 1.2.6 vulnerable to prototype pollution'
    }
  };
}

function getKnownPythonVulnerabilities(): Record<string, any> {
  return {
    'urllib3': {
      severity: 'high' as const,
      cve_id: 'CVE-2023-45803',
      description: 'Request smuggling vulnerability',
      details: 'Versions before 1.26.18 vulnerable to HTTP request smuggling'
    },
    'requests': {
      severity: 'medium' as const,
      cve_id: 'CVE-2023-32681',
      description: 'Proxy-Authorization header leak',
      details: 'Versions before 2.31.0 may leak Proxy-Authorization headers'
    },
    'django': {
      severity: 'high' as const,
      cve_id: 'CVE-2023-43665',
      description: 'Denial of service',
      details: 'Certain versions vulnerable to DoS via large file uploads'
    }
  };
}

function getKnownRustVulnerabilities(): Record<string, any> {
  return {
    'serde': {
      severity: 'high' as const,
      cve_id: 'RUSTSEC-2023-0072',
      description: 'Stack overflow vulnerability',
      details: 'Certain versions vulnerable to stack overflow'
    },
    'openssl': {
      severity: 'critical' as const,
      cve_id: 'RUSTSEC-2023-0044',
      description: 'OpenSSL vulnerabilities',
      details: 'Multiple security issues in OpenSSL bindings'
    }
  };
}

export function calculateVulnerabilitySummary(vulnerabilities: Vulnerability[]): VulnerabilitySummary {
  const summary: VulnerabilitySummary = {
    total_count: vulnerabilities.length,
    critical_count: 0,
    high_count: 0,
    medium_count: 0,
    low_count: 0,
    by_type: {
      dependency: 0,
      code_pattern: 0,
      configuration: 0
    }
  };

  for (const vuln of vulnerabilities) {
    switch (vuln.severity) {
      case 'critical':
        summary.critical_count++;
        break;
      case 'high':
        summary.high_count++;
        break;
      case 'medium':
        summary.medium_count++;
        break;
      case 'low':
        summary.low_count++;
        break;
    }

    summary.by_type[vuln.type]++;
  }

  return summary;
}
